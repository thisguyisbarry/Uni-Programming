#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Function to drive forward at some angle, distance and power
void drive(long nMotorRatio, long dist, long power)
{
	setMotorSyncEncoder(leftMotor, rightMotor, nMotorRatio, dist, power);

	//This won't allow the program to continue until the robot stops
	waitUntilMotorStop(motorB);
}

//Function to turn a 90 degree angle
void turn90(long nMotorRatio, long power)
{
	//Turn the robot 90 degrees
	setMotorSyncEncoder(leftMotor, rightMotor, nMotorRatio, 500, power);

	//This won't allow the program to continue until the robot stops
	waitUntilMotorStop(motorB);
}

task main()
{
	int ranDirection = random(1);

 //Straight (motor ratio of zero) a distance of 1320 encoder cycles (equiv of ~60cm, 22 cycles per cm)
	drive(0, 1000, 50);

 //Depending on the random number generated (1 or 0) the robot will commit to going left or right
	if (ranDirection == 0)
  {
  	turn90(50,50);
  	drive(0, 1320, 50);  //Approx 22 cycles per cm so 60 cm is 1320 cycles
  	turn90(50,50);
  	drive(0, 1320, 50);
  	turn90(50,50);
	}
	else
	{
		turn90(-50,50);
		drive(0, 1320, 50);
		turn90(-50,50);
		drive(0, 1320, 50);
		turn90(-50,50);
	}

	//Back to start of square
	drive(0, 1320, 50);

	//Drive forward 100cm (2200 cycles) at 100% power, turn 180 degrees and return to origin at 25% power
	drive(0, 2200, 100);
	turn90(50,50);
	turn90(50,50);
	drive(0, 2200, 25);

}
